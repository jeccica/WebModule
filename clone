#!/usr/bin/env node

var _USAGE = _multiline(function() {/*
    See https://github.com/uupaa/WebModule/wiki/Development
*/});

//  fileName                    [scan, sourceFileName]

var _CLONE_FILES = {
    "alt": {
        "REPOSITORY_NAME.ts":   [true],
    },
    "bin": {
        "REPOSITORY_NAME.js":   [true],
    },
    "lib": {
        "REPOSITORY_NAME.js":   [true],
    },
    "lint": {
        "plato": {
            "README.md":        [],
        }
    },
    "release": {
        "README.md":            [],
    },
    "test": {
        "test.js":              [true],
    },
    ".gitignore":               [],
    ".jshintrc":                [],
    ".npmignore":               [],
    ".travis.yml":              [],
    "index.js":                 [true, "MODULE_index.js"],
//  "LICENSE":                  [true, "MODULE_LICENSE"],
    "package.json":             [true, "MODULE_package.json"],
    "README.md":                [true, "MODULE_README.md"]
};

var _CONSOLE_COLOR = {
        RED:    "\u001b[31m",
        YELLOW: "\u001b[33m",
        GREEN:  "\u001b[32m",
        CLEAR:  "\u001b[0m"
    };

var fs                 = require("fs");
var readline           = require("readline");
var childProcess       = require("child_process");
var Task               = require("uupaa.task.js");
var argv               = process.argv.slice(2);
var githubUserName     = argv[0] || "";

var repositoryFullName = process.cwd().split("/").pop();
var repositoryName     = repositoryFullName.indexOf(".") >= 0
                       ? repositoryFullName.split(".").slice(0, -1).join(".")
                       : repositoryFullName;

var fromDir            = process.argv[1].split("/").slice(0, -1).join("/") + "/";
var toDir              = process.cwd() + "/";

// console.log( "repositoryFullName: " + repositoryFullName  ); // "Foo.js"
// console.log( "repositoryName:     " + repositoryName      ); // "Foo"
// console.log( "fromDir:            " + fromDir             ); // "/Users/uupaa/oss/WebModule/"
// console.log( "toDir:              " + toDir               ); // "/Users/uupaa/oss/Foo.js"
// return;

var options = _parseCommandLineOptions({
        help:       false,      // Boolean: true is show help.
        verbose:    false,      // Boolean: true is verbose mode.
        alt:        false,      // boolean: true is put alt/ dir.
        bin:        false,      // boolean: true is put bin/ dir.
    });

if (options.verbose) {
    console.log(_CONSOLE_COLOR.YELLOW + _USAGE + _CONSOLE_COLOR.CLEAR);
    return;
}

if (!options.alt) {
    delete _CLONE_FILES.alt;
}
if (!options.bin) {
    delete _CLONE_FILES.bin;
}

getGitHubUserName(function(stdout, stderr) {

    githubUserName = stdout;
    _clone(fromDir, toDir, _CLONE_FILES, function() {
        console.log("  ");
        console.log(_CONSOLE_COLOR.GREEN + "  finished." + _CONSOLE_COLOR.CLEAR);
        console.log(_CONSOLE_COLOR.GREEN + "  Use the following command `npm run init`." + _CONSOLE_COLOR.CLEAR);
    });

}, function(err) {
    console.error(_CONSOLE_COLOR.RED + "Error: git config --get user.name" + _CONSOLE_COLOR.CLEAR);
});

// =========================================================
function getGitHubUserName(callback, errorCallback) {
    if (githubUserName) {
        callback(githubUserName);
        return;
    }
    childProcess.exec("git config --get user.name 2> /dev/null", function(err, stdout, stderr) {
        if (err) {
            if (errorCallback) {
                errorCallback(err);
            }
        } else {
            callback(stdout.trim());
        }
    });
}

function _clone(fromDir,    // @arg String - copy from dir. has tail slash(/)
                toDir,      // @arg String - copy to dir. has tail slash(/)
                fileTree,   // @arg Object - source file tree.
                callback) { // @arg Function - finished callback.

    var overwriteFiles = []; // [ [targetFile, sourceText], ... ]

    _doClone(overwriteFiles, fromDir, toDir, fileTree);

    if (overwriteFiles.length) {
        var rl = readline.createInterface(process.stdin, process.stdout);
        Task.loop(overwriteFiles, _tick, function() {
            rl.close();
            callback();
        });

        function _tick(task, index, overwriteFiles) {
            var ary = overwriteFiles[index];
            var targetFile = ary[0];
            var sourceText = ary[1];

            rl.question("  exists:    " + targetFile + " - overwrite it? (y/n): ",
                       function(answer) {

                if (/^y$/i.test(answer)) {
                    console.log(_CONSOLE_COLOR.YELLOW + "  overwrite: " + targetFile + _CONSOLE_COLOR.CLEAR);
                    fs.writeFileSync(targetFile, sourceText);
                } else {
                    console.log("  skip:      " + targetFile);
                }
                task.pass();
            });
        }
    } else {
        callback();
    }
}

function _doClone(overwriteFiles, fromDir, toDir, fileTree) {
    for (fileName in fileTree) {
        _loop(overwriteFiles, fileName, fileTree);
    }

    function _loop(overwriteFiles, // @arg FileStringArray - ["file", ...]
                   fileName,       // @arg FileNameString|DirNameString - "MODULE_README.md", "lib"
                   fileTree) {     // @arg Object - _CLONE_FILES or _CLONE_FILES subtree.
        var options        = fileTree[fileName]; // [scan, sourceFileName]
        var scan           = options[0] || false;
        var sourceFileName = options[1] || "";
        var isFileEntry    = Array.isArray(options);

        if ( !isFileEntry ) { // is directory entry
            if ( !fs.existsSync(toDir + fileName) ) {
                console.log("  mkdir:     " + toDir + fileName + "/");
                fs.mkdirSync(toDir + fileName);
            }
            // recursive call
            _doClone(overwriteFiles,
                     fromDir + fileName + "/",
                     toDir   + fileName + "/",
                     fileTree[fileName]);

        } else {
            var sourceFile = fromDir + (sourceFileName || fileName);
            var targetFile = toDir   + fileName;

            // replace fileName. "lib/REPOSITORY_NAME.js" -> "lib/Foo.js"
            targetFile = _repleaceText(targetFile);

            var targetFileAlreadyExists = fs.existsSync(targetFile);
            var sourceText = fs.readFileSync(sourceFile, "UTF-8");
            var targetText = targetFileAlreadyExists ? fs.readFileSync(targetFile, "UTF-8") : "";

            if (scan) {
                sourceText = _repleaceText(sourceText);
            }
            if (targetText && targetText !== sourceText) {
                overwriteFiles.push([targetFile, sourceText]);
            } else {
                if (targetFileAlreadyExists) {
                    console.log("  overwrite: " + targetFile);
                } else {
                    console.log("  clone:     " + targetFile);
                }
                fs.writeFileSync(targetFile, sourceText);
            }
        }
    }

    function _repleaceText(text) {
        text = text.replace(/GITHUB_USER_NAME/g,          githubUserName);                   // "uupaa"
        text = text.replace(/LOWER_REPOSITORY_FULLNAME/g, repositoryFullName.toLowerCase()); // "foo.js"
        text = text.replace(/LOWER_REPOSITORY_NAME/g,     repositoryName.toLowerCase());     // "foo"
        text = text.replace(/REPOSITORY_FULLNAME/g,       repositoryFullName);               // "Foo.js"
        text = text.replace(/REPOSITORY_NAME/g,           repositoryName);                   // "Foo"
        text = text.replace(/WEBMODULE_IDIOM/g,           "(this || 0).self || global");

        return text;
    }
}

function _parseCommandLineOptions(options) { // @arg Object:
                                             // @ret Object:
    for (var i = 0, iz = argv.length; i < iz; ++i) {
        switch (argv[i]) {
        case "-h":
        case "--help":      options.help = true; break;
        case "-v":
        case "--verbose":   options.verbose = true; break;
        case "--alt":       options.alt = true; break;
        case "--bin":       options.bin = true; break;
        default:
        }
    }
    return options;
}

function _multiline(fn) { // @arg Function:
                          // @ret String:
    return (fn + "").split("\n").slice(1, -1).join("\n");
}

